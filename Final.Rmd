---
title: "Dynastic Impacts on Political Outcomes"
output:
  pdf_document: default
  html_document:
    df_print: paged
subtitle: Replication and Extension of Smith and Martin (2017)
header-includes:
- \usepackage{setspace}\doublespacing
- \usepackage{float}
- \usepackage[labelformat=empty]{caption}
---

\begin{flushright}
Jack Schroeder

Gov 1006 Final Paper

April 31, 2019
\end{flushright}

## Abstract  

In this project, I analyze Smith and Martin (2017)'s "Political Dynasties and the Selection of Cabinet Ministers". I begin by replicating Smith and Martin (2017)'s figures and tables. While some of this output cannot be replicated due to missing data or the inability to reproduce in R (the authors used Stata), I find similar results to the authors in what was producible. From there, I extend the results by using their dataset to analyze the gendered impact of two covariates, dynasty and local experience, on winning election.  

## Introduction  

The importance of political dynasties in legislatures cannot be understated.  

## Literature Review  

Whether these dynasties are beneficial is another question entirely. Using economic data from India, Eapen George and Ponattu (2017) estiamte that dynastic rule tends to slow economic growth within each dynastic constituency, worsen the provision of public goods across constitutencies, and heighten ethnic polarization among voters. This evidence goes against the common refrain that members of political dynasties are better at legislating because of a greater familiarity with the political system. Indeed, it may be the case that dynasties lead to worse governance. Tusalem and Pe-Aguirre (2013) conclude through their analysis of dynasties in the Philippines that provinces dominated by dynasties tend to spend money less effectively on infrastructure and health than other provinces, while they also have more crime and unemployment. Most strikingly, even though the presence of dynasties tends to incude higher levels of congressional earmarks, dynasties spend the money less effectively than their counterparts.  

That said, there is reason to believe dynasties can be normatively beneficial. Lacriox et al (2019) analyze the French Parliament during the initial stages of World War Two and find that members of dynasties were significantly more pro-democratic in their voting records than non-dynasties. However, there were striking disparities between dynasties, leading the authors to conclude that there exist separate types of dynasties, each with their own goals toward coalescing power. While dynasties founded by or filled by members of a pro-democratic party (or non-affiliated members who openly supported a democratic France) tended to defend democratic rights, other dynasties acted no more democratic than non-dynasties.  

## Why Ireland?  

Closely choose candidates, weak parties, multimember districts, explain STV.  

```{r setup, include=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)

# I load in three libraries. The first, lfe, allows me to regress using absorbed
# fixed effects (similar to the absorb function in Stata). The second, stargazer,
# lets me create regression output tables. The third is tidyverse, which is useful
# when wrangling with data.

library(lfe)
library(stargazer)
library(tidyverse)

# Smith and Martin leave two data files in the Dataverse. Both of them contain the same
# data. Since I'm more familiar with reading in a csv file versus a dta file (and I
# want to limit the libraries called), I read in their csv data in as csv_data.

csv_data <- read_csv("Smith-Martin-Replication-Data/IRELAND-CANDIDATES.csv")

```


```{r data cleaning, echo=FALSE, cache=TRUE}

# Smith and Martin recode a lot of values before going into their analysis.

csv_data <- csv_data %>% 

# The first mutate is a scalar value of whether a politician is a legacy. What are these
# values? pre_mp is equal to 1 if past family members were elected to the Dail
# (Ireland's) lower house. cablegacy is coded 1 if their direct predecessor served in
# cabinet. All other values on this scale are equal to 0.
  
  mutate(legacyscale = case_when(cablegacy == 1 ~ 2,
                                 pre_mp == 1 ~ 1,
                                 TRUE ~ 0),

# I then add a dynasty variable for my extension. This is a binary equal to 1 if the 
# candidate qualifies as a dynasty.
         
         dynasty = case_when(legacyscale > 0 ~ 1,
                             TRUE ~ 0),
  
# cwins is the number of times (including the current term) the candidate has won
# election to the Dail. est_age is the estimated age of each candidate (if unknown) or
# the actual age (which is found in age). This age is taken from when the candidate
# runs/wins for the first time. Presumably Smith and Martin wanted to see if these
# numbers are still influential on an exponential scale.

         cwins2 = cwins^2,
        est_age2 = est_age^2,
        age2 = age^2,

# Then we have to recode some values already in the dataset into groups. The first is
# a group of estimated ages. The next is recoding educode to new values. educode refers
# to the highest degree received. 1 is primary school, 2 is secondary school, 3 is 
# tertiary, 4 university, and 5 postgraduate. They recode tertiary and university to have
# the same value in educode2.

        agegroup = case_when(est_age > 29 ~ 1,
                             est_age > 39 ~ 2,
                             est_age > 49 ~ 3,
                             est_age > 59 ~ 4,
                             TRUE ~ 0),
        educode2 = case_when(educode == 2 ~ 1,
                             educode == 3 ~ 2,
                             educode == 4 ~ 2,
                             educode == 5 ~ 3,
                             TRUE ~ as.double(educode)),

# offprof is whether the candidate had an "official" profession (which I think refers to
# a senior level). I code that using a case_when.

        offprof = case_when(iscoid < 3 ~ 1,
                            TRUE ~ 0),

# I also found it really helpful to recode legacyscale as the actual name values used in
# graphing (nonlegacy, noncabinet legacy, and cabinet legacy). I assign this to
# legacyname.

        legacyname = case_when(legacyscale == 0 ~ "Nonlegacy",
                               legacyscale == 1 ~ "Noncabinet legacy",
                               legacyscale == 2 ~ "Cabinet legacy"),

# The next recode focuses on the Dail term. There had been 32 Dail terms by 2016, but 
# the current dataset only looks at them as the term number. Since these terms have
# varying lengths, recoding them into years may yield stronger results on legacy.

        dailyear = case_when(dail ==  1 ~ 1918 ,
                             dail ==  2 ~ 1921,
                             dail ==  3 ~ 1922,
                             dail ==  4 ~ 1923,
                             dail ==  5 ~ 1927,
                             dail ==  6  ~ 1927,
                             dail ==  7 ~ 1932,
                             dail ==  8 ~ 1933,
                             dail ==  9 ~ 1937,
                             dail ==  10 ~ 1938,
                             dail ==  11 ~ 1943,
                             dail ==  12 ~ 1944,
                             dail ==  13 ~ 1948,
                             dail ==  14 ~ 1951,
                             dail ==  15 ~ 1954,
                             dail ==  16 ~ 1957,
                             dail ==  17 ~ 1961,
                             dail ==  18 ~ 1965,
                             dail ==  19 ~ 1969,
                             dail ==  20 ~ 1973,
                             dail ==  21 ~ 1977,
                             dail ==  22 ~ 1981,
                             dail ==  23 ~ 1982,
                             dail ==  24 ~ 1982,
                             dail ==  25 ~ 1987,
                             dail ==  26 ~ 1989,
                             dail ==  27 ~ 1992,
                             dail ==  28 ~ 1997,
                             dail ==  29 ~ 2002,
                             dail ==  30 ~ 2007,
                             dail ==  31 ~ 2011,
                             dail ==  32 ~ 2016),

# Another large case_when recode here with assigning districts to regions 
# for Table 7. This was even longer in the original Stata.

        region = case_when(district == "Carlow Kildare" | 
                             district == "Carlow Kilkenny" | 
                             district == "Kildare" | 
                             district == "Kildare North" |
                             district == "Kildare South" ~ "Carlow-Kildare-Kilkenny",
                           district == "Cavan" | 
                             district == "Cavan Monaghan" | 
                             district == "Monaghan" ~ "Cavan Monaghan",
                           district == "Clare" | 
                             district == "Clare Galway South" ~ "Clare-Galway",
                           district == "Cork Borough" | 
                             district == "Cork City" |
                             district == "Cork City North" | 
                             district == "Cork City South" | 
                             district == "Cork East" | 
                             district == "Cork Mid" | 
                             district == "Cork North" | 
                             district == "Cork North Central" |
                             district == "Cork North East" | 
                             district == "Cork North West" | 
                             district == "Cork South" | 
                             district == "Cork South Central" |
                             district == "Cork South East" | 
                             district == "Cork South West" | 
                             district == "Cork West" ~ "Cork",
                           district == "Donegal" | 
                             district == "Donegal East" | 
                             district == "Donegal Leitrim" | 
                             district == "Donegal North East" | 
                             district == "Donegal South West" | 
                             district == "Donegal West" ~ "Donegal",
                           district == "Dublin Artane" | 
                             district == "Dublin Ballyfermot"| 
                             district == "Dublin Cabra" | 
                             district == "Dublin Central" |
                             district == "Dublin Clontarf" | 
                             district == "Dublin County" |
                             district == "Dublin County Mid" | 
                             district == "Dublin County North" | 
                             district == "Dublin County South" | 
                             district == "Dublin County West" | 
                             district == "Dublin Finglas" | 
                             district == "Dublin Mid West" | 
                             district == "Dublin North" | 
                             district == "Dublin North Central" | 
                             district == "Dublin North East" | 
                             district == "Dublin North West" | 
                             district == "Dublin Rathmines" | 
                             district == "Dublin South" | 
                             district == "Dublin South Central" | 
                             district == "Dublin South East" | 
                             district == "Dublin South West" | 
                             district == "Dublin Townships" | 
                             district == "Dublin West" | 
                             district == "Dun Laoghaire" | 
                             district == "Dun Laoghaire Rathdown" ~ "Dublin",
                           district == "Galway East" | 
                             district == "Galway North" | 
                             district == "Galway North East" | 
                             district == "Galway South" | 
                             district == "Galway West" ~ "Clare-Galway",
                           district == "Kerry North" | 
                             district == "Kerry North-West Limerick" | 
                             district == "Kerry South" ~ "Kerry",
                           district == "Laoighis Offaly" | 
                             district == "Leix Offaly" ~ "Laois-Offaly",
                           district == "Limerick" | 
                             district == "Limerick City" | 
                             district == "Limerick County" | 
                             district == "Limerick East" | 
                             district == "Limerick West" ~ "Limerick",
                           district == "Mayo" | 
                             district == "Mayo East" | 
                             district == "Mayo North" | 
                             district == "Mayo South" | 
                             district == "Mayo West" ~ "Mayo",
                           district == "Athlone Longford" | 
                             district == "Longford Westmeath" | 
                             district == "Meath" | 
                             district == "Meath East" | 
                             district == "Meath West" | 
                             district == "Meath Westmeath" | 
                             district == "Westmeath" ~ "Meath-Westmeath",
                           district == "Leitrim" | 
                             district == "Longford Roscommon" | 
                             district == "Roscommon" | 
                             district == "Roscommon Leitrim" | 
                             district == "Roscommon Leitrim South" | 
                             district == "Sligo" | 
                             district == "Sligo Leitrim" | 
                             district == "Sligo Leitrim North" ~
                             "Sligo-Leitrim-Roscommon",
                           district == "Tipperary" | 
                             district == "Tipperary North" | 
                             district == "Tipperary South" ~ "Tipperary",
                           TRUE ~ district),

# Smith and Martin also recode a few partyid values to a new vector named
# partyidsimple. The changes are minor. Christian Centrists are lumped in with
# the Christian Solidarity, Sinn Fein's workers' parties are lumped in with
# the other workers' parties, Independent Fianna Fail and Fine Gael are recoded
# into their larger counterparts, and some smaller parties are recoded into the
# value 30, which contains other minor parties and non-parties.

      partyidsimple = case_when(partyid == 9 ~ 8,
                                partyid == 14 ~ 15,
                                partyid == 11 ~ 1,
                                partyid == 12 ~ 2,
                                partyid == 16 ~ 30,
                                partyid == 18 ~ 30,
                                partyid == 23 ~ 30,
                                partyid == 26 ~ 30,
                                partyid == 16 ~ 30,
                                TRUE ~ as.double(partyid))) %>% 
  
# Lastly, Smith and Martin filter out results from before 1944. This
# is done to focus on the previous 20 Dails.
  
  filter(elecyear > 1943) %>% 

# Another thing needs to be taken care of first. There was an Irish 
# politician named James Dillon. He was an independent associated with
# the Fine Gael party for most of his career. Smith and Martin go to
# great lengths to make sure he is coded as FG throughout the entire
# dataset. This makes enough sense from a cursory glance of his electoral
# history: he was leader of FG from 1959-1965. I'll indulge the authors and
# recode him.

  mutate(party = case_when(name == "Dillon, James" ~ "FG",
                           TRUE ~ party),
         partyid = case_when(name == "Dillon, James" ~ 2,
                             TRUE ~ as.double(partyid)),
         govparty = case_when(name == "Dillon, James" & elecyear == 1948 ~ 1,
                              TRUE ~ as.double(govparty)),
         firstrun = case_when(cruns == 1 ~ 1,
                              TRUE ~ 0)) %>% 

# Smith and Martin combine some variables into new ones. I do the same using
# the unite function.
  
  unite("party_year", c("partyidsimple", "elecyear"), remove=FALSE) %>% 
  unite("dist_year", c("districtid", "elecyear"), remove=FALSE) %>% 
  unite("party_dail", c("partyidsimple", "dail"), remove=FALSE) %>% 
  unite("party_dist", c("partyid", "districtid"), remove=FALSE) %>% 
  unite("party_region", c("partyid", "region"), remove=FALSE) %>% 
  unite("party_dist_dail", c("partyid", "districtid", "dail"), remove=FALSE) %>% 
  unite("party_region_dail", c("partyid" , "region", "dail"), remove=FALSE)

# There are quite a few rejoins necessary here since some new variables are
# summary data (and some of those are conditional on other factors). I create
# new dataframes for them but will rejoin them back to csv_data after they are
# all created. 

# first_age is the initial age of each candidate when they ran for the first
# time.

first_age <- csv_data %>% 
  group_by(pid) %>% 
  mutate(first_age = min(est_age)) %>% 
  group_by(pid) %>% 
  summarize(first_age = min(first_age))

# first_party is the first party of each candidate.

first_party <- csv_data %>% 
  group_by(pid) %>% 
  mutate(first_party = case_when(cruns == 1 ~ party, TRUE ~ "NA")) %>% 
  group_by(pid) %>% 
  summarize(first_party = min(first_party))

# prelocal looks at whether a candidate had local office experience
# before running for the first time.

prelocal <- csv_data %>% 
  group_by(pid) %>% 
  summarize(prelocal = min(local))

# preseanad analyzes whether a candidate served in the Seanad before
# running for the first time.

preseanad <- csv_data %>% 
  group_by(pid) %>% 
  summarize(preseanad = min(seanad))

# prevwins is how many wins the candidate has had at the time of
# the election.

prevwins <- csv_data %>% 
  mutate(prevwins = cwins) %>% 
  group_by(pid) %>% 
  mutate(prevwins = case_when(result == 1 ~ as.double(prevwins)-1,
                                 TRUE ~ as.double(prevwins))) %>% 
  group_by(pid) %>% 
  summarize(prevwins = min(prevwins))

# ever_elected is coded to 1 if the candidate ever won an election.

ever_elected <- csv_data %>% 
  group_by(pid) %>% 
  summarize(max = max(cwins)) %>% 
  mutate(ever_elected = case_when(max > 0 ~ 1,
                                max == 0 ~ 0)) %>% 
  select(pid, ever_elected)

# I rejoin all of this data back to csv_data.

csv_data <- csv_data %>% 
  full_join(., first_age, by = "pid") %>% 
  full_join(., first_party, by = "pid") %>%
  full_join(., prelocal, by = "pid") %>% 
  full_join(., preseanad, by = "pid") %>% 
  full_join(., prevwins, by = "pid") %>%
  full_join(., ever_elected, by = "pid") %>% 
  
# I also create prevwins2, which is prevwins squared.
  
  mutate(prevwins2 = prevwins ^ 2)

# Changing legacyname into a factor and releveling it helps make the 
# graphs look presentable for the figures.

csv_data$legacyname <- fct_relevel(csv_data$legacyname, c("Nonlegacy", "Noncabinet legacy", "Cabinet legacy"))

write_rds(csv_data, "Presentation-figure/smdata.rds")

```

## Replication  

Smith and Martin (2017) use Stata to create the 7 tables and 6 figures in the paper. As a result, my output does not perfectly match their paper cosmetically. That said, the results are mostly the same. It is entirely possible, though, that using `ggplot2` makes the figures look better and that some of the regression coefficients are off on the hundredths digit and beyond.  

There are some tables and figures that could not be replicated. There was no replication code for Tables 1 and 2 in the Stata code. As a result, I did not attempt to replicate this portion of the paper. Table 1 is a list of the cabinets and governing parties in Ireland from 1944-2016. The cabinets, dates in office, and governing parties are not given in the data, although it would theoretically be possible to figure out whether Fianna Fail or Fine Gael had a majority in the Dail based on which party won more seats in the most recent election. However, the cabinet and Prime Minister would not be able to be determined from this data, so I left it untouched. Table 2 is a Stata summary table of the family relationships and generations among candidates and TDs. While this table is replicable in R, since the code to create it was not included, I decided to focus on replicating the other tables and figures. The figure not included in this replication is Figure 5, which was used to help explain the informational advantage by analyzing several different controls of experience, demographics, and education. This type of coefficient plot is possible in R, but getting the results to directly match the one in the paper was not possible (and would have looked too disjointed to include).  

Those exceptions aside, Smith and Martin (2017)'s results replicate well. There were two major hurdles in replication: translating Stata code and managing multiple graphs. I was able to recreate most of the figures and tables using the `ggplot2` and `stargazer` libraries, respectively. However, the majority of the replication code focused on cleaning the candidate dataset and adding new variables. Using the `tidyverse`, I was able to condense some of the hard-coding relative to the amount used in Stata. The foremost example of this was when the authors added regional data (to create regional fixed effects). In Stata, the authors had to individually assign each district to a region, but by using the `case_when` function, I was able to assign multiple districts to a single region, which cut down the workload by a decent amount. The second hurdle was multiple graphs within the same figure. The majority of the authors' figures were comprised of three bar graphs, mostly reporting summaries of different attributes along the legacy scale. While there exist ways to save multiple graphs within the same figure, I decided it was best to keep each individual call for `ggplot` separate in case I wanted to call one graph and not another in the final paper.  

### Figures  

```{r fig1, echo=FALSE, cache=TRUE}

# Figure 1 is a stacked bar plot looking at the proportion of legacies among
# candidates, elected TDs, TDs in the coalition party, and cabinet ministers.
# To make Figure 1, I had to do a decent amount of data wrangling. This first
# required me to make percentages of legacy status among each of the four 
# politician categories outlined above.

f1_c <- csv_data %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "Candidates") %>% 
  select(-n)

f1_td <- csv_data %>% 
  filter(result == 1) %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "TDs") %>% 
  select(-n)

f1_gtd <- csv_data %>% 
  filter(result == 1, govparty == 1) %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "Government TDs") %>% 
  select(-n)

f1_cm <- csv_data %>% 
  filter(cabappt == 1) %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "Cabinet Ministers") %>% 
  select(-n)

# From there, I used rbind to create a long dataset. I also
# made position and legacy name into a factor variables that I 
# releveled to make the graph look better.

f1 <- rbind(f1_c, f1_td, f1_gtd, f1_cm)
f1$position <- as.factor(f1$position)
f1$position <- fct_relevel(f1$position, "Candidates", "TDs", "Government TDs", "Cabinet Ministers")
f1$legacyname <- fct_relevel(f1$legacyname, "Cabinet legacy", "Noncabinet legacy",
                             "Nonlegacy")

# From there, I just had to use ggplot with the fill, stat, and
# position attributes correctly selected to show the values on top
# of one another and in the proper order. I titled and labeled 
# appropriately.

f1 <- f1 %>% 
  ggplot(aes(x=reorder(position, -per), y=per, fill=legacyname)) +
  geom_bar(stat="identity", position="fill") +
  xlab("") +
  ylab("Percent") +
  ggtitle("Figure 1. Politician Legacy Proportions", subtitle = "In the Republic of Ireland, 1944-2016") +
  guides(fill=guide_legend(title="Legacy Type"))

```

```{r figdata, echo=FALSE, cache=TRUE}

# A lot of the figures rely on the same subset of data.
# I create that new data here. This data is the csv data but
# only looking at candidates who at one point won election.

figdata <- csv_data %>% 
  filter(ever_elected == 1)

```

```{r fig2, echo=FALSE, cache=TRUE}

# Figure 2 (and 3 and 4) look at attribute data prior to election.
# Unlike Figure 1, they are not stacked bar plots. This makes things
# a bit easier when wrangling data. All I have to do is create the proper
# percentages before calling for ggplot. Keep in mind that in the paper 
# and in this replication, many of these figures are multiple graphs.

f2_local <- figdata %>% 
  filter(!is.na(prelocal)) %>% 
  count(legacyname, prelocal) %>% 
  spread(prelocal, n) %>% 
  mutate(per_local = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_local)

f2_seanad <- figdata %>% 
  filter(!is.na(preseanad)) %>% 
  count(legacyname, preseanad) %>% 
  spread(preseanad, n) %>% 
  mutate(per_seanad = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_seanad)

f2_offprof <- figdata %>% 
  filter(!is.na(offprof)) %>% 
  count(legacyname, offprof) %>% 
  spread(offprof, n) %>% 
  mutate(per_offprof = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_offprof)

# I call ggplot three times to create the three displayed graphs.

f2_1 <- ggplot(f2_local, aes(x=legacyname, y=per_local, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 2. Pre-Electoral Experience (Local)", subtitle = "Sorted by Legacy Status")

f2_2 <- ggplot(f2_seanad, aes(x=legacyname, y=per_seanad, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 2. Pre-Electoral Experience (Seanad)", subtitle = "Sorted by Legacy Status")

f2_3 <- ggplot(f2_offprof, aes(x=legacyname, y=per_offprof, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 2. Pre-Electoral Experience (Professional)", subtitle = "Sorted by Legacy Status")

```

```{r fig3, echo=FALSE, cache=TRUE}

# Whereas Figure 2 looked at experience data, Figure 3 looks at demographic
# data. I do the same data wrangling process as for Figure 2.

f3_female <- figdata %>% 
  filter(!is.na(female)) %>% 
  count(legacyname, female) %>% 
  spread(female, n) %>% 
  mutate(per_female = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_female)

f3_first_age <- figdata %>% 
  filter(!is.na(first_age)) %>% 
  group_by(legacyname) %>% 
  summarize(avg_first_age = mean(first_age)) %>% 
  select(legacyname, avg_first_age)

f3_localborn <- figdata %>% 
  filter(!is.na(localborn)) %>% 
  count(legacyname, localborn) %>% 
  spread(localborn, n) %>% 
  mutate(per_localborn = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_localborn)

# Then I just call three ggplots and display the results.

f3_1 <- ggplot(f3_female, aes(x=legacyname, y=per_female, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 3. Pre-Electoral Demographics (Female)", subtitle = "Sorted by Legacy Status")

f3_2 <- ggplot(f3_first_age, aes(x=legacyname, y=avg_first_age, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 3. Pre-Electoral Demographics (Age at First Election)", subtitle = "Sorted by Legacy Status")

f3_3 <- ggplot(f3_localborn, aes(x=legacyname, y=per_localborn, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 3. Pre-Electoral Demographics (Local Born)", subtitle = "Sorted by Legacy Status")

```

```{r fig4, echo=FALSE, cache=TRUE}

# Figure 4 looks at the same pre-electoral attribute data, but focusing on 
# education. I do the same commands to data wrangle.

f4_postsec <- figdata %>% 
  filter(!is.na(educode2)) %>% 
  count(legacyname, educode2) %>% 
  spread(educode2, n) %>% 
  mutate(per_postsec = `2`/(`1`+`2`+`3`)) %>% 
  select(legacyname, per_postsec)

f4_postgrad <- figdata %>% 
  filter(!is.na(educode2)) %>% 
  count(legacyname, educode2) %>% 
  spread(educode2, n) %>% 
  mutate(per_postgrad = `3`/(`1`+`2`+`3`)) %>% 
  select(legacyname, per_postgrad)

f4_ucd <- figdata %>% 
  filter(!is.na(ucd)) %>% 
  count(legacyname, ucd) %>% 
  spread(ucd, n) %>% 
  mutate(per_ucd = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_ucd)

f4_feeschool <- figdata %>% 
  filter(!is.na(feeschool)) %>% 
  count(legacyname, feeschool) %>% 
  spread(feeschool, n) %>% 
  mutate(per_feeschool = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_feeschool)

# Then I call ggplot four times to display the four layers of output.

f4_1 <- ggplot(f4_postsec, aes(x=legacyname, y=per_postsec, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (Postsecondary Education)", subtitle = "Sorted by Legacy Status")

f4_2 <- ggplot(f4_postgrad, aes(x=legacyname, y=per_postgrad, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (Postgraduate Degree)", subtitle = "Sorted by Legacy Status")

f4_3 <- ggplot(f4_ucd, aes(x=legacyname, y=per_ucd, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (UCD)", subtitle = "Sorted by Legacy Status")

f4_4 <- ggplot(f4_feeschool, aes(x=legacyname, y=per_feeschool, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (Fee School)", subtitle = "Sorted by Legacy Status")

```

```{r fig6, echo=FALSE, cache=TRUE}

# Figure 6 contrasts cabinet and noncabinet legacies through legacy
# attributes (generation number, sharing the same name/district as
# the predecessor in the dynasty). Generation is shown as the number,
# while same name and same district are shown in percentage form.

fig6data <- figdata %>% 
  filter(pre_mp == 1,
         legacyscale != 0)

f6_generation <- fig6data %>% 
  filter(!is.na(generation)) %>% 
  group_by(legacyname) %>% 
  summarize(avg_generation = mean(generation)) %>% 
  select(legacyname, avg_generation)

f6_samename <- fig6data %>% 
  filter(!is.na(samename)) %>% 
  count(legacyname, samename) %>% 
  spread(samename, n) %>% 
  mutate(per_samename = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_samename)

f6_samedistrict <- fig6data %>% 
  filter(!is.na(samedistrict)) %>% 
  count(legacyname, samedistrict) %>% 
  spread(samedistrict, n) %>% 
  mutate(per_samedistrict = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_samedistrict)

# I call three ggplots to display the output.

f6_1 <- ggplot(f6_generation, aes(x=legacyname, y=avg_generation, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 6. Strength of the Dynasty (Generation)", subtitle = "Sorted by Legacy Status")

f6_2 <- ggplot(f6_samename, aes(x=legacyname, y=per_samename, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 6. Strength of the Dynasty (Same Name)", subtitle = "Sorted by Legacy Status")

f6_3 <- ggplot(f6_samedistrict, aes(x=legacyname, y=per_samedistrict, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 6. Strength of the Dynasty (Same District)", subtitle = "Sorted by Legacy Status")

```

### Tables  

```{r t3, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 3 measures the electoral advantage of legacies. It uses the
# election result as its left-hand variable. I use felm here because
# Smith and Martin absorb some of their fixed effects (like party-year),
# and regular lm won't let me do that. All of this uses csv_data. I create
# each model.

# Model 1 is simply looking at legacy's impact on winning.

t3_1 <- felm(result ~ as.factor(legacyscale), csv_data)

# Model 2 is legacy's impact on winning, but with party-year fixed effects.

t3_2 <- felm(result ~ as.factor(legacyscale) | party_year, csv_data)

# Model 3 is the same as Model 2 but with district-year fixed effects.

t3_3 <- felm(result ~ as.factor(legacyscale) | dist_year, csv_data)

# Model 4 looks at being female and being a first-time candidate, along with
# party-year fixed effects.

t3_4 <- felm(result ~ as.factor(legacyscale) + female + firstrun | party_year, csv_data)

# Model 5 reproduces Model 4 but with district-year fixed effects.

t3_5 <- felm(result ~ as.factor(legacyscale) + female + firstrun | dist_year, csv_data)

# I display the output using stargazer.

t3 <- stargazer(t3_1, t3_2, t3_4,
          title = "Table 3. The Electoral Advantage of Legacy: Election Result",
          header = FALSE,
          covariate.labels = c("Noncabinet Legacy", "Cabinet Legacy", "Female", "First Run"),
          dep.var.labels = "Election Result",
          omit.stat = "rsq",
          add.lines = list(c("Party-Year Fixed Effects?", "No", "Yes", "Yes")))

```

```{r t4, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 4 looks at the electoral advantage of legacy, but with quota share
# as the measured output variable. quotashare is the proportion of the Droop
# Quota (used in multimember districts to determine who wins) met by the 
# candidate's first preference votes.

# Model 1 is simply legacy's impact on quota achieved.

t4_1 <- felm(quotashare ~ as.factor(legacyscale), csv_data)

# Model 2 is similar to Model 1 but with party-year fixed effects.

t4_2 <- felm(quotashare ~ as.factor(legacyscale) | party_year, csv_data)

# Model 3 is the same as Model 1 but with district-year fixed effects.

t4_3 <- felm(quotashare ~ as.factor(legacyscale) | dist_year, csv_data)

# Model 4 adds being female and being a first-time candidate to Model 2.

t4_4 <- felm(quotashare ~ as.factor(legacyscale) + female + firstrun | party_year, csv_data)

# Model 5 is the same as Model 4, but with district-year fixed effects.

t4_5 <- felm(quotashare ~ as.factor(legacyscale) + female + firstrun | dist_year, csv_data)

# I display the output with stargazer.

t4 <- stargazer(t4_1, t4_2, t4_3, t4_4, t4_5,
          title = "Table 4. The Electoral Advantage of Legacy: Share of Quota",
          header = FALSE)

```

```{r t5, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 5 looks at cabinet appointment as the output variable. It seeks
# to find out whether legacies have an advantage in getting on cabinet.

# Model 1 looks at legacy's impact on cabinet appointment with no effects.

t5_1 <- felm(cabappt ~ as.factor(legacyscale), csv_data)

# Model 2 adds party fixed effects to Model 1.

t5_2 <- felm(cabappt ~ as.factor(legacyscale) | partyidsimple, csv_data)

# Model 3 adds party-dail fixed effects to Model 1 (similar to party-year
# effects, but focused on which government has power).

t5_3 <- felm(cabappt ~ as.factor(legacyscale) | party_dail, csv_data)

# Model 4 adds candidate wins (and candidate wins squared), along with 
# party-dail fixed effects.

t5_4 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 | party_dail, 
             csv_data)

# Model 5 adds quota share to Model 4.

t5_5 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + quotashare | 
               party_dail, csv_data)

# I display the output with stargazer.

t5 <- stargazer(t5_1, t5_3, t5_4, t5_5,
          title = "Table 5. The Legacy Advantage in Cabinet Selection",
          covariate.labels = c("Noncabinet Legacy", "Cabinet Legacy", "Election Wins", "Election Wins Sq.", "Share of Droop Quota"),
          dep.var.labels = "Cabinet Appointment",
          omit.stat = "rsq",
          add.lines = list(c("Party-Year Fixed Effects?", "No", "Yes", "Yes", "Yes")),
          header = FALSE)

```

```{r t6, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 6 looks at what makes dynasties strong. The output variable is still
# cabinet appointment.

# Model 1 looks at the impact of legacy type, candidate wins, candidate wins squared,
# and which generation in the legacy the candidate is on cabinet appointment. It
# also has party-dail fixed effects. The data is subsetted to legacies.

t6_1 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + generation | 
               party_dail, subset(csv_data, pre_mp == 1))

# Model 2 is the same as Model 1 but uses whether the candidate has the same name
# as the dynasty rather than generation.

t6_2 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + samename | 
               party_dail, subset(csv_data, pre_mp == 1))

# Model 3 looks at whether the candidate is from the same district as the dynasty
# rather than the same name.

t6_3 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + samedistrict |
               party_dail, subset(csv_data, pre_mp == 1))

# I display the output with stargazer.

t6 <- stargazer(t6_1, t6_2, t6_3,
          title = "Table 6. Unpacking the Informational Advantage: Strength of the Dynasty?",
          header = FALSE)

```

```{r t7, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# All of the region hard-coding comes to fruition in Table 7, which
# analyzes whether region has an effect on the impact of legacy. Cabinet 
# appointment is still the output variable.

# Model 1 looks at the impat of legacy on cabinet appointment, with party-region
# fixed effects.

t7_1 <- felm(cabappt ~ as.factor(legacyscale) | party_region_dail, csv_data)

# Model 2 looks adds candidate wins and candidate wins squared to Model 1.

t7_2 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 | 
               party_region_dail, csv_data)

# I display the output with stargazer.

t7 <- stargazer(t7_1, t7_2,
          title = "Table 7. Unpacking the Informational Advantage: Party Strongholds?",
          header = FALSE)

```

## Extension  

I will extend Smith and Martin (2017) in two ways: analyzing the gendered effect of dynasties on winning election and looking at the effect of another potentially gendered covariate, local experience, on winning election.  

### Gendered Effect of Dynasty  

Smith and Martin (2017) note that "legacies of both types are more likely to be women, which suggests that dynasties may be a significant pathway into politics for female candidate in an otherwise male-dominated parliament" (p. 151). This observation inspired me to dig deeper into the gendered effects of being in a political dynasty. Does being in a dynasty help female candidates counteract the gender gap in winning elections?  

To answer this question, I manipulated the Smith and Martin (2017) dataset to include a binary varible, `dynasty`, that was coded 1 if the candidate qualified as a dynasty. I then regressed election result on that and the candidate's sex. I ended up with three models: one that had no fixed effects, one that used the party-year fixed effects from Smith and Martin (2017), and one that used the authors' district-year fixed effects. That output is below in Table X.  

That said, it must be mentioned that this analysis is not unique. After creating my models, I found that one of the co-authors of the initial paper, Daniel Smith, currently has a working paper that studies this same topic with a similar dataset using approximately the same modeling technique. As a result, this portion of the extension should be characterized as a replication of Folke, Rickne, and Smith (2017) since, while I did not know it at the time, they were the first to flesh out this idea. This portion of the extension also serves as a replication of Folke, Rickne, and Smith (2017) who, with a similar dataset to Smith and Martin (2017), question whether there is a gender-specific impact to being a legacy in terms of winning election.  

The major difference between my analysis and Folke, Rickne, and Smith (2017) is that they restrict their sample to Ireland's three major parties (Fianna Fail, Fine Gael, and Labour). They justify this decision because those parties have been consistently nominating candidates in most districts. However, I think the results should still hold without subsetting the data in this fashion because (a) there is still a model that creates party-year fixed effects and (b) since Ireland's electoral system places an emphasis on individual candidates, it should not necessarily matter that a party was consistently nominating in each district.  

```{r extension 1, echo=FALSE, warning=FALSE, results='asis'}

library(lfe)
library(stargazer)

te1_1 <- felm(result ~ female*dynasty, data=csv_data)

te1_2 <- felm(result ~ female*dynasty | party_dail, data=csv_data)

te1_3 <- felm(result ~ female*dynasty | dist_year, data=csv_data)

te1 <- stargazer(te1_1, te1_2, te1_3,
                 title = "Table X: Gendered Effect of Dynasty",
                 header=FALSE,
                 add.lines = list(c("Fixed Effects?", "No", "Party-Year", "District-Year")),
                 covariate.labels = c("Female",
                                      "Dynasty",
                                      "Female * Dynasty"),
                 dep.var.caption = "Dependent Variable:",
                 dep.var.labels = "Election Result")
```


### Gendered Effect of Local Experience  

I then wondered whether other covariates could have differing effects by gender. I thought local political experience was an interesting covariate to study because there seem to be two schools of thought surrounding its gendered effects.  

The first is pessimistic. Okimoto and Brescoll (2010) observe that female candidates seen as ambitious are punished by voters, while male candidates seen in a similar light are not penalized. Excluding a general "feeling" potential voters could get after meeting a candidate face-to-face or watching them in a debate, local experience seems to be the best signal for ambition available to study. While the overall effect of holding local office is positive for men, the effect for women would be expected to be diminished or even negative if the "ambition hypothesis" holds.  

The second possibility is more optimistic about the effect of local experience on female representation, even though it relies on a sexist electorate. Survey data from Fox (2003) demonstrates that fewer women run for office than men because they are more pessimistic about their qualifications. Additionally, research from Huddy and Terkildsen (1993) suggests that female candidates are held to a higher standard than male candidates in elections. It follows, then, that local experience can both incentivize better female candidates to run and give them the extra qualifications necessary to beat male candidates. In fact, if the assumptions prove true, female candidates should gain more benefit from local experience than male candidates do since the electorate seemingly demands more qualifications from women before voting them into office. As a result, the effect of women holding local office should counteract the gender gap.  

To determine which of these hypotheses most accurately reflected the data, I recreated the models from the first extension and applied them to the interaction between candidate sex and local political experience. Again, three models were created: one without fixed effects, one taking party-year effects into account, and one taking district-year effects into account. As in the first extension, I did not subset the data to only include the major parties. The results of the models are summarized below in Table X.  

```{r extension 2, echo=FALSE, warning=FALSE, results='asis'}

te2_1 <- felm(result ~ female*local, data=csv_data)

te2_2 <- felm(result ~ female*local | party_dail, data=csv_data)

te2_3 <- felm(result ~ female*local | dist_year, data=csv_data)

te2 <- stargazer(te2_1, te2_2, te2_3,
                 title = "Table Y: Gendered Effect of Local Experience",
                 header=FALSE,
                 add.lines = list(c("Fixed Effects?", "No", "Party-Year", "District-Year")),
                 covariate.labels = c("Female",
                                      "Local Experience",
                                      "Female * Local Experience"),
                 dep.var.caption = "Dependent Variable:",
                 dep.var.labels = "Election Result")
```


## Appendix  

Below are the figures and tables included in Smith and Martin (2017) that I chose not to display in the "Replication" portion of the paper.  

```{r}

```


## References  

Folke, O., Rickne, J., and Smith, D. (2017). Gender and dynastic political recruitment. *Research Institute of*

\    *Industrial Economics*. Retrieved from ifn.se

Smith, D., and Martin, S. (2017). Political dynasties and the selection of cabinet ministers. *Legislative* 

\    *Studies Quarterly 42*(1). Retrieved from wiley.com

Smith, D., and Martin, S. (2017). Replication data for: Political dynasties and the selection of cabinet 

\    ministers. *Harvard Dataverse*. Retrieved from dataverse.harvard.edu