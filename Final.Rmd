---
title: "Final Project"
author: "Jack Schroeder"
date: "4/4/2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
citation_package: natbib
bibliography: references.bib
---


## Abstract

In this project, I analyze @article's "Political Dynasties and the Selection of Cabinet Ministers". I begin by replicating @article's figures and tables. While some of this output cannot be replicated due to missing data or the inability to reproduce in R (the authors used Stata), I find similar results to the authors in what was producible. From there, I will extend their results in a variety of ways.

```{r setup, include=FALSE, cache=TRUE}
knitr::opts_chunk$set(echo = TRUE)

# I load in three libraries. The first, lfe, allows me to regress using absorbed
# fixed effects (similar to the absorb function in Stata). The second, stargazer,
# lets me create regression output tables. The third is tidyverse, which is useful
# when wrangling with data.

library(lfe)
library(stargazer)
library(tidyverse)

# Smith and Martin leave two data files in the Dataverse. Both of them contain the same
# data. Since I'm more familiar with reading in a csv file versus a dta file (and I
# want to limit the libraries called), I read in their csv data in as csv_data.

csv_data <- read_csv("Smith-Martin-Replication-Data/IRELAND-CANDIDATES.csv")

```


```{r data cleaning, echo=FALSE, cache=TRUE}

# Smith and Martin recode a lot of values before going into their analysis. I am going
# to translate this part of their work and leave the figures themselves for a later
# time.

csv_data <- csv_data %>% 

# The first mutate is a scalar value of whether a politician is a legacy. What are these
# values? pre_mp is equal to 1 if past family members were elected to the Dail
# (Ireland's) lower house. cablegacy is coded 1 if their direct predecessor served in
# cabinet. All other values on this scale are equal to 0.
  
  mutate(legacyscale = case_when(cablegacy == 1 ~ 2,
                                 pre_mp == 1 ~ 1,
                                 TRUE ~ 0),
  
# cwins is the number of times (including the current term) the candidate has won
# election to the Dail. est_age is the estimated age of each candidate (if unknown) or
# the actual age (which is found in age). This age is taken from when the candidate
# runs/wins for the first time. Presumably Smith and Martin wanted to see if these
# numbers are still influential on an exponential scale.

         cwins2 = cwins^2,
        est_age2 = est_age^2,
        age2 = age^2,

# Then we have to recode some values already in the dataset into groups. The first is
# a group of estimated ages. The next is recoding educode to new values. educode refers
# to the highest degree received. 1 is primary school, 2 is secondary school, 3 is 
# tertiary, 4 university, and 5 postgraduate. They recode tertiary and university to have
# the same value in educode2.

        agegroup = case_when(est_age > 29 ~ 1,
                             est_age > 39 ~ 2,
                             est_age > 49 ~ 3,
                             est_age > 59 ~ 4,
                             TRUE ~ 0),
        educode2 = case_when(educode == 2 ~ 1,
                             educode == 3 ~ 2,
                             educode == 4 ~ 2,
                             educode == 5 ~ 3,
                             TRUE ~ as.double(educode)),

# offprof is whether the candidate had an "official" profession (which I think refers to
# a senior level). I code that using a case_when.

        offprof = case_when(iscoid < 3 ~ 1,
                            TRUE ~ 0),

# I also found it really helpful to recode legacyscale as the actual name values used in
# graphing (nonlegacy, noncabinet legacy, and cabinet legacy). I assign this to
# legacyname.

        legacyname = case_when(legacyscale == 0 ~ "Nonlegacy",
                               legacyscale == 1 ~ "Noncabinet legacy",
                               legacyscale == 2 ~ "Cabinet legacy"),

# The next recode focuses on the Dail term. There had been 32 Dail terms by 2016, but 
# the current dataset only looks at them as the term number. Since these terms have
# varying lengths, recoding them into years may yield stronger results on legacy.

        dailyear = case_when(dail ==  1 ~ 1918 ,
                             dail ==  2 ~ 1921,
                             dail ==  3 ~ 1922,
                             dail ==  4 ~ 1923,
                             dail ==  5 ~ 1927,
                             dail ==  6  ~ 1927,
                             dail ==  7 ~ 1932,
                             dail ==  8 ~ 1933,
                             dail ==  9 ~ 1937,
                             dail ==  10 ~ 1938,
                             dail ==  11 ~ 1943,
                             dail ==  12 ~ 1944,
                             dail ==  13 ~ 1948,
                             dail ==  14 ~ 1951,
                             dail ==  15 ~ 1954,
                             dail ==  16 ~ 1957,
                             dail ==  17 ~ 1961,
                             dail ==  18 ~ 1965,
                             dail ==  19 ~ 1969,
                             dail ==  20 ~ 1973,
                             dail ==  21 ~ 1977,
                             dail ==  22 ~ 1981,
                             dail ==  23 ~ 1982,
                             dail ==  24 ~ 1982,
                             dail ==  25 ~ 1987,
                             dail ==  26 ~ 1989,
                             dail ==  27 ~ 1992,
                             dail ==  28 ~ 1997,
                             dail ==  29 ~ 2002,
                             dail ==  30 ~ 2007,
                             dail ==  31 ~ 2011,
                             dail ==  32 ~ 2016),

# Another large case_when recode here with assigning districts to regions 
# for Table 7. This was even longer in the original Stata.

        region = case_when(district == "Carlow Kildare" | 
                             district == "Carlow Kilkenny" | 
                             district == "Kildare" | 
                             district == "Kildare North" |
                             district == "Kildare South" ~ "Carlow-Kildare-Kilkenny",
                           district == "Cavan" | 
                             district == "Cavan Monaghan" | 
                             district == "Monaghan" ~ "Cavan Monaghan",
                           district == "Clare" | 
                             district == "Clare Galway South" ~ "Clare-Galway",
                           district == "Cork Borough" | 
                             district == "Cork City" |
                             district == "Cork City North" | 
                             district == "Cork City South" | 
                             district == "Cork East" | 
                             district == "Cork Mid" | 
                             district == "Cork North" | 
                             district == "Cork North Central" |
                             district == "Cork North East" | 
                             district == "Cork North West" | 
                             district == "Cork South" | 
                             district == "Cork South Central" |
                             district == "Cork South East" | 
                             district == "Cork South West" | 
                             district == "Cork West" ~ "Cork",
                           district == "Donegal" | 
                             district == "Donegal East" | 
                             district == "Donegal Leitrim" | 
                             district == "Donegal North East" | 
                             district == "Donegal South West" | 
                             district == "Donegal West" ~ "Donegal",
                           district == "Dublin Artane" | 
                             district == "Dublin Ballyfermot"| 
                             district == "Dublin Cabra" | 
                             district == "Dublin Central" |
                             district == "Dublin Clontarf" | 
                             district == "Dublin County" |
                             district == "Dublin County Mid" | 
                             district == "Dublin County North" | 
                             district == "Dublin County South" | 
                             district == "Dublin County West" | 
                             district == "Dublin Finglas" | 
                             district == "Dublin Mid West" | 
                             district == "Dublin North" | 
                             district == "Dublin North Central" | 
                             district == "Dublin North East" | 
                             district == "Dublin North West" | 
                             district == "Dublin Rathmines" | 
                             district == "Dublin South" | 
                             district == "Dublin South Central" | 
                             district == "Dublin South East" | 
                             district == "Dublin South West" | 
                             district == "Dublin Townships" | 
                             district == "Dublin West" | 
                             district == "Dun Laoghaire" | 
                             district == "Dun Laoghaire Rathdown" ~ "Dublin",
                           district == "Galway East" | 
                             district == "Galway North" | 
                             district == "Galway North East" | 
                             district == "Galway South" | 
                             district == "Galway West" ~ "Clare-Galway",
                           district == "Kerry North" | 
                             district == "Kerry North-West Limerick" | 
                             district == "Kerry South" ~ "Kerry",
                           district == "Laoighis Offaly" | 
                             district == "Leix Offaly" ~ "Laois-Offaly",
                           district == "Limerick" | 
                             district == "Limerick City" | 
                             district == "Limerick County" | 
                             district == "Limerick East" | 
                             district == "Limerick West" ~ "Limerick",
                           district == "Mayo" | 
                             district == "Mayo East" | 
                             district == "Mayo North" | 
                             district == "Mayo South" | 
                             district == "Mayo West" ~ "Mayo",
                           district == "Athlone Longford" | 
                             district == "Longford Westmeath" | 
                             district == "Meath" | 
                             district == "Meath East" | 
                             district == "Meath West" | 
                             district == "Meath Westmeath" | 
                             district == "Westmeath" ~ "Meath-Westmeath",
                           district == "Leitrim" | 
                             district == "Longford Roscommon" | 
                             district == "Roscommon" | 
                             district == "Roscommon Leitrim" | 
                             district == "Roscommon Leitrim South" | 
                             district == "Sligo" | 
                             district == "Sligo Leitrim" | 
                             district == "Sligo Leitrim North" ~
                             "Sligo-Leitrim-Roscommon",
                           district == "Tipperary" | 
                             district == "Tipperary North" | 
                             district == "Tipperary South" ~ "Tipperary",
                           TRUE ~ district),

# Smith and Martin also recode a few partyid values to a new vector named
# partyidsimple. The changes are minor. Christian Centrists are lumped in with
# the Christian Solidarity, Sinn Fein's workers' parties are lumped in with
# the other workers' parties, Independent Fianna Fail and Fine Gael are recoded
# into their larger counterparts, and some smaller parties are recoded into the
# value 30, which contains other minor parties and non-parties.

      partyidsimple = case_when(partyid == 9 ~ 8,
                                partyid == 14 ~ 15,
                                partyid == 11 ~ 1,
                                partyid == 12 ~ 2,
                                partyid == 16 ~ 30,
                                partyid == 18 ~ 30,
                                partyid == 23 ~ 30,
                                partyid == 26 ~ 30,
                                partyid == 16 ~ 30,
                                TRUE ~ as.double(partyid))) %>% 
  
# Lastly, Smith and Martin filter out results from before 1944. This
# is done to focus on the previous 20 Dails.
  
  filter(elecyear > 1943) %>% 

# Another thing needs to be taken care of first. There was an Irish 
# politician named James Dillon. He was an independent associated with
# the Fine Gael party for most of his career. Smith and Martin go to
# great lengths to make sure he is coded as FG throughout the entire
# dataset. This makes enough sense from a cursory glance of his electoral
# history: he was leader of FG from 1959-1965. I'll indulge the authors and
# recode him.

  mutate(party = case_when(name == "Dillon, James" ~ "FG",
                           TRUE ~ party),
         partyid = case_when(name == "Dillon, James" ~ 2,
                             TRUE ~ as.double(partyid)),
         govparty = case_when(name == "Dillon, James" & elecyear == 1948 ~ 1,
                              TRUE ~ as.double(govparty)),
         firstrun = case_when(cruns == 1 ~ 1,
                              TRUE ~ 0)) %>% 

# Smith and Martin combine some variables into new ones. I do the same using
# the unite function.
  
  unite("party_year", c("partyidsimple", "elecyear"), remove=FALSE) %>% 
  unite("dist_year", c("districtid", "elecyear"), remove=FALSE) %>% 
  unite("party_dail", c("partyidsimple", "dail"), remove=FALSE) %>% 
  unite("party_dist", c("partyid", "districtid"), remove=FALSE) %>% 
  unite("party_region", c("partyid", "region"), remove=FALSE) %>% 
  unite("party_dist_dail", c("partyid", "districtid", "dail"), remove=FALSE) %>% 
  unite("party_region_dail", c("partyid" , "region", "dail"), remove=FALSE)

# There are quite a few rejoins necessary here since some new variables are
# summary data (and some of those are conditional on other factors). I create
# new dataframes for them but will rejoin them back to csv_data after they are
# all created. 

# first_age is the initial age of each candidate when they ran for the first
# time.

first_age <- csv_data %>% 
  group_by(pid) %>% 
  mutate(first_age = min(est_age)) %>% 
  group_by(pid) %>% 
  summarize(first_age = min(first_age))

# first_party is the first party of each candidate.

first_party <- csv_data %>% 
  group_by(pid) %>% 
  mutate(first_party = case_when(cruns == 1 ~ party, TRUE ~ "NA")) %>% 
  group_by(pid) %>% 
  summarize(first_party = min(first_party))

# prelocal looks at whether a candidate had local office experience
# before running for the first time.

prelocal <- csv_data %>% 
  group_by(pid) %>% 
  summarize(prelocal = min(local))

# preseanad analyzes whether a candidate served in the Seanad before
# running for the first time.

preseanad <- csv_data %>% 
  group_by(pid) %>% 
  summarize(preseanad = min(seanad))

# prevwins is how many wins the candidate has had at the time of
# the election.

prevwins <- csv_data %>% 
  mutate(prevwins = cwins) %>% 
  group_by(pid) %>% 
  mutate(prevwins = case_when(result == 1 ~ as.double(prevwins)-1,
                                 TRUE ~ as.double(prevwins))) %>% 
  group_by(pid) %>% 
  summarize(prevwins = min(prevwins))

# ever_elected is coded to 1 if the candidate ever won an election.

ever_elected <- csv_data %>% 
  group_by(pid) %>% 
  summarize(max = max(cwins)) %>% 
  mutate(ever_elected = case_when(max > 0 ~ 1,
                                max == 0 ~ 0)) %>% 
  select(pid, ever_elected)

# I rejoin all of this data back to csv_data.

csv_data <- csv_data %>% 
  full_join(., first_age, by = "pid") %>% 
  full_join(., first_party, by = "pid") %>%
  full_join(., prelocal, by = "pid") %>% 
  full_join(., preseanad, by = "pid") %>% 
  full_join(., prevwins, by = "pid") %>%
  full_join(., ever_elected, by = "pid") %>% 
  
# I also create prevwins2, which is prevwins squared.
  
  mutate(prevwins2 = prevwins ^ 2)

# Changing legacyname into a factor and releveling it helps make the 
# graphs look presentable for the figures.

csv_data$legacyname <- fct_relevel(csv_data$legacyname, c("Nonlegacy", "Noncabinet legacy", "Cabinet legacy"))

```

## Replication

@data use Stata to create the 7 tables and 6 figures in the paper. As a result, my output does not perfectly match their paper cosmetically. That said, the results are the same (save that the graphs look a bit better and some of the regression numbers are ever so slightly off). @data  fail to include replication code to create Tables 1 or 2. The replication code create Figure 5 cannot be translated into R. Although I may try producing them on my own later, I am skipping them for now.

### Figures

```{r fig1, echo=FALSE, cache=TRUE}

# Figure 1 is a stacked bar plot looking at the proportion of legacies among
# candidates, elected TDs, TDs in the coalition party, and cabinet ministers.
# To make Figure 1, I had to do a decent amount of data wrangling. This first
# required me to make percentages of legacy status among each of the four 
# politician categories outlined above.

f1_c <- csv_data %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "Candidates") %>% 
  select(-n)

f1_td <- csv_data %>% 
  filter(result == 1) %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "TDs") %>% 
  select(-n)

f1_gtd <- csv_data %>% 
  filter(result == 1, govparty == 1) %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "Government TDs") %>% 
  select(-n)

f1_cm <- csv_data %>% 
  filter(cabappt == 1) %>% 
  count(legacyname) %>% 
  mutate(per = n/sum(n),
         position = "Cabinet Ministers") %>% 
  select(-n)

# From there, I used rbind to create a long dataset. I also
# made position and legacy name into a factor variables that I 
# releveled to make the graph look better.

f1 <- rbind(f1_c, f1_td, f1_gtd, f1_cm)
f1$position <- as.factor(f1$position)
f1$position <- fct_relevel(f1$position, "Candidates", "TDs", "Government TDs", "Cabinet Ministers")
f1$legacyname <- fct_relevel(f1$legacyname, "Cabinet legacy", "Noncabinet legacy",
                             "Nonlegacy")

# From there, I just had to use ggplot with the fill, stat, and
# position attributes correctly selected to show the values on top
# of one another and in the proper order. I titled and labeled 
# appropriately.

f1 %>% 
  ggplot(aes(x=reorder(position, -per), y=per, fill=legacyname)) +
  geom_bar(stat="identity", position="fill") +
  xlab("") +
  ylab("Percent") +
  ggtitle("Figure 1. Politician Legacy Proportions", subtitle = "In the Republic of Ireland, 1944-2016")

```

```{r figdata, echo=FALSE, cache=TRUE}

# A lot of the figures rely on the same subset of data.
# I create that new data here. This data is the csv data but
# only looking at candidates who at one point won election.

figdata <- csv_data %>% 
  filter(ever_elected == 1)

```

```{r fig2, echo=FALSE, cache=TRUE}

# Figure 2 (and 3 and 4) look at attribute data prior to election.
# Unlike Figure 1, they are not stacked bar plots. This makes things
# a bit easier when wrangling data. All I have to do is create the proper
# percentages before calling for ggplot. Keep in mind that in the paper 
# and in this replication, many of these figures are multiple graphs.

f2_local <- figdata %>% 
  filter(!is.na(prelocal)) %>% 
  count(legacyname, prelocal) %>% 
  spread(prelocal, n) %>% 
  mutate(per_local = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_local)

f2_seanad <- figdata %>% 
  filter(!is.na(preseanad)) %>% 
  count(legacyname, preseanad) %>% 
  spread(preseanad, n) %>% 
  mutate(per_seanad = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_seanad)

f2_offprof <- figdata %>% 
  filter(!is.na(offprof)) %>% 
  count(legacyname, offprof) %>% 
  spread(offprof, n) %>% 
  mutate(per_offprof = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_offprof)

# I call ggplot three times to create the three displayed graphs.

ggplot(f2_local, aes(x=legacyname, y=per_local, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 2. Pre-Electoral Experience (Local)", subtitle = "Sorted by Legacy Status")

ggplot(f2_seanad, aes(x=legacyname, y=per_seanad, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 2. Pre-Electoral Experience (Seanad)", subtitle = "Sorted by Legacy Status")

ggplot(f2_offprof, aes(x=legacyname, y=per_offprof, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 2. Pre-Electoral Experience (Professional)", subtitle = "Sorted by Legacy Status")

```

```{r fig3, echo=FALSE, cache=TRUE}

# Whereas Figure 2 looked at experience data, Figure 3 looks at demographic
# data. I do the same data wrangling process as for Figure 2.

f3_female <- figdata %>% 
  filter(!is.na(female)) %>% 
  count(legacyname, female) %>% 
  spread(female, n) %>% 
  mutate(per_female = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_female)

f3_first_age <- figdata %>% 
  filter(!is.na(first_age)) %>% 
  group_by(legacyname) %>% 
  summarize(avg_first_age = mean(first_age)) %>% 
  select(legacyname, avg_first_age)

f3_localborn <- figdata %>% 
  filter(!is.na(localborn)) %>% 
  count(legacyname, localborn) %>% 
  spread(localborn, n) %>% 
  mutate(per_localborn = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_localborn)

# Then I just call three ggplots and display the results.

ggplot(f3_female, aes(x=legacyname, y=per_female, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 3. Pre-Electoral Demographics (Female)", subtitle = "Sorted by Legacy Status")

ggplot(f3_first_age, aes(x=legacyname, y=avg_first_age, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 3. Pre-Electoral Demographics (Age at First Election)", subtitle = "Sorted by Legacy Status")

ggplot(f3_localborn, aes(x=legacyname, y=per_localborn, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 3. Pre-Electoral Demographics (Local Born)", subtitle = "Sorted by Legacy Status")

```

```{r fig4, echo=FALSE, cache=TRUE}

# Figure 4 looks at the same pre-electoral attribute data, but focusing on 
# education. I do the same commands to data wrangle.

f4_postsec <- figdata %>% 
  filter(!is.na(educode2)) %>% 
  count(legacyname, educode2) %>% 
  spread(educode2, n) %>% 
  mutate(per_postsec = `2`/(`1`+`2`+`3`)) %>% 
  select(legacyname, per_postsec)

f4_postgrad <- figdata %>% 
  filter(!is.na(educode2)) %>% 
  count(legacyname, educode2) %>% 
  spread(educode2, n) %>% 
  mutate(per_postgrad = `3`/(`1`+`2`+`3`)) %>% 
  select(legacyname, per_postgrad)

f4_ucd <- figdata %>% 
  filter(!is.na(ucd)) %>% 
  count(legacyname, ucd) %>% 
  spread(ucd, n) %>% 
  mutate(per_ucd = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_ucd)

f4_feeschool <- figdata %>% 
  filter(!is.na(feeschool)) %>% 
  count(legacyname, feeschool) %>% 
  spread(feeschool, n) %>% 
  mutate(per_feeschool = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_feeschool)

# Then I call ggplot four times to display the four layers of output.

ggplot(f4_postsec, aes(x=legacyname, y=per_postsec, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (Postsecondary Education)", subtitle = "Sorted by Legacy Status")

ggplot(f4_postgrad, aes(x=legacyname, y=per_postgrad, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (Postgraduate Degree)", subtitle = "Sorted by Legacy Status")

ggplot(f4_ucd, aes(x=legacyname, y=per_ucd, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (UCD)", subtitle = "Sorted by Legacy Status")

ggplot(f4_feeschool, aes(x=legacyname, y=per_feeschool, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 4. Pre-Electoral Education (Fee School)", subtitle = "Sorted by Legacy Status")

```

```{r fig6, echo=FALSE, cache=TRUE}

# Figure 6 contrasts cabinet and noncabinet legacies through legacy
# attributes (generation number, sharing the same name/district as
# the predecessor in the dynasty). Generation is shown as the number,
# while same name and same district are shown in percentage form.

fig6data <- figdata %>% 
  filter(pre_mp == 1,
         legacyscale != 0)

f6_generation <- fig6data %>% 
  filter(!is.na(generation)) %>% 
  group_by(legacyname) %>% 
  summarize(avg_generation = mean(generation)) %>% 
  select(legacyname, avg_generation)

f6_samename <- fig6data %>% 
  filter(!is.na(samename)) %>% 
  count(legacyname, samename) %>% 
  spread(samename, n) %>% 
  mutate(per_samename = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_samename)

f6_samedistrict <- fig6data %>% 
  filter(!is.na(samedistrict)) %>% 
  count(legacyname, samedistrict) %>% 
  spread(samedistrict, n) %>% 
  mutate(per_samedistrict = `1`/(`1`+`0`)) %>% 
  select(legacyname, per_samedistrict)

# I call three ggplots to display the output.

ggplot(f6_generation, aes(x=legacyname, y=avg_generation, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 6. Strength of the Dynasty (Generation)", subtitle = "Sorted by Legacy Status")

ggplot(f6_samename, aes(x=legacyname, y=per_samename, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 6. Strength of the Dynasty (Same Name)", subtitle = "Sorted by Legacy Status")

ggplot(f6_samedistrict, aes(x=legacyname, y=per_samedistrict, fill=legacyname)) + 
  geom_bar(stat="identity") + 
  xlab("") +
  ylab("") +
  ggtitle("Figure 6. Strength of the Dynasty (Same District)", subtitle = "Sorted by Legacy Status")

```

### Tables

```{r t3, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 3 measures the electoral advantage of legacies. It uses the
# election result as its left-hand variable. I use felm here because
# Smith and Martin absorb some of their fixed effects (like party-year),
# and regular lm won't let me do that. All of this uses csv_data. I create
# each model.

# Model 1 is simply looking at legacy's impact on winning.

t3_1 <- felm(result ~ as.factor(legacyscale), csv_data)

# Model 2 is legacy's impact on winning, but with party-year fixed effects.

t3_2 <- felm(result ~ as.factor(legacyscale) | party_year, csv_data)

# Model 3 is the same as Model 2 but with district-year fixed effects.

t3_3 <- felm(result ~ as.factor(legacyscale) | dist_year, csv_data)

# Model 4 looks at being female and being a first-time candidate, along with
# party-year fixed effects.

t3_4 <- felm(result ~ as.factor(legacyscale) + female + firstrun | party_year, csv_data)

# Model 5 reproduces Model 4 but with district-year fixed effects.

t3_5 <- felm(result ~ as.factor(legacyscale) + female + firstrun | dist_year, csv_data)

# I display the output using stargazer.

stargazer(t3_1, t3_2, t3_3, t3_4, t3_5,
          title = "Table 3. The Electoral Advantage of Legacy: Election Result",
          type = 'html')

```

```{r t4, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 4 looks at the electoral advantage of legacy, but with quota share
# as the measured output variable. quotashare is the proportion of the Droop
# Quota (used in multimember districts to determine who wins) met by the 
# candidate's first preference votes.

# Model 1 is simply legacy's impact on quota achieved.

t4_1 <- felm(quotashare ~ as.factor(legacyscale), csv_data)

# Model 2 is similar to Model 1 but with party-year fixed effects.

t4_2 <- felm(quotashare ~ as.factor(legacyscale) | party_year, csv_data)

# Model 3 is the same as Model 1 but with district-year fixed effects.

t4_3 <- felm(quotashare ~ as.factor(legacyscale) | dist_year, csv_data)

# Model 4 adds being female and being a first-time candidate to Model 2.

t4_4 <- felm(quotashare ~ as.factor(legacyscale) + female + firstrun | party_year, csv_data)

# Model 5 is the same as Model 4, but with district-year fixed effects.

t4_5 <- felm(quotashare ~ as.factor(legacyscale) + female + firstrun | dist_year, csv_data)

# I display the output with stargazer.

stargazer(t4_1, t4_2, t4_3, t4_4, t4_5,
          title = "Table 4. The Electoral Advantage of Legacy: Share of Quota",
          type = 'html')

```

```{r t5, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 5 looks at cabinet appointment as the output variable. It seeks
# to find out whether legacies have an advantage in getting on cabinet.

# Model 1 looks at legacy's impact on cabinet appointment with no effects.

t5_1 <- felm(cabappt ~ as.factor(legacyscale), csv_data)

# Model 2 adds party fixed effects to Model 1.

t5_2 <- felm(cabappt ~ as.factor(legacyscale) | partyidsimple, csv_data)

# Model 3 adds party-dail fixed effects to Model 1 (similar to party-year
# effects, but focused on which government has power).

t5_3 <- felm(cabappt ~ as.factor(legacyscale) | party_dail, csv_data)

# Model 4 adds candidate wins (and candidate wins squared), along with 
# party-dail fixed effects.

t5_4 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 | party_dail, 
             csv_data)

# Model 5 adds quota share to Model 4.

t5_5 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + quotashare | 
               party_dail, csv_data)

# I display the output with stargazer.

stargazer(t5_1, t5_2, t5_3, t5_4, t5_5,
          title = "Table 5. The Legacy Advantage in Cabinet Selection",
          type = 'html')

```

```{r t6, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# Table 6 looks at what makes dynasties strong. The output variable is still
# cabinet appointment.

# Model 1 looks at the impact of legacy type, candidate wins, candidate wins squared,
# and which generation in the legacy the candidate is on cabinet appointment. It
# also has party-dail fixed effects. The data is subsetted to legacies.

t6_1 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + generation | 
               party_dail, subset(csv_data, pre_mp == 1))

# Model 2 is the same as Model 1 but uses whether the candidate has the same name
# as the dynasty rather than generation.

t6_2 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + samename | 
               party_dail, subset(csv_data, pre_mp == 1))

# Model 3 looks at whether the candidate is from the same district as the dynasty
# rather than the same name.

t6_3 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 + samedistrict |
               party_dail, subset(csv_data, pre_mp == 1))

# I display the output with stargazer.

stargazer(t6_1, t6_2, t6_3,
          title = "Table 6. Unpacking the Informational Advantage: Strength of the Dynasty?",
          type = 'html')

```

```{r t7, echo=FALSE, warning=FALSE, cache=TRUE, results='asis'}

# All of the region hard-coding comes to fruition in Table 7, which
# analyzes whether region has an effect on the impact of legacy. Cabinet 
# appointment is still the output variable.

# Model 1 looks at the impat of legacy on cabinet appointment, with party-region
# fixed effects.

t7_1 <- felm(cabappt ~ as.factor(legacyscale) | party_region_dail, csv_data)

# Model 2 looks adds candidate wins and candidate wins squared to Model 1.

t7_2 <- felm(cabappt ~ as.factor(legacyscale) + cwins + cwins2 | 
               party_region_dail, csv_data)

# I display the output with stargazer.

stargazer(t7_1, t7_2,
          title = "Table 7. Unpacking the Informational Advantage: Party Strongholds?",
          type = 'html')

```


## References

It appears the reference format we normally use isn't entirely working for me yet. This will be fixed!